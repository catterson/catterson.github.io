y <- sin(x) + rnorm(n, sd = 2)
d <- data.frame(x, y)
# Graphin the fake data.
ggplot(data, aes(x = x, y = y)) +
geom_point(size = 2) +
#stat_smooth(method = "lm", formula = y ~ poly(x, 25), se = FALSE, color = "red", size = 2) +
#labs(title = "Overfit Model (25-Degree Polynomial IV") +
theme_minimal()
library(ggplot2)
# Fakin' some data.
set.seed(42)
n <- 100
x <- seq(-5, 5, n)
y <- sin(x) + rnorm(n, sd = 5)
d <- data.frame(x, y)
# Graphin the fake data.
ggplot(data, aes(x = x, y = y)) +
geom_point(size = 2) +
#stat_smooth(method = "lm", formula = y ~ poly(x, 25), se = FALSE, color = "red", size = 2) +
#labs(title = "Overfit Model (25-Degree Polynomial IV") +
theme_minimal()
library(ggplot2)
# Fakin' some data.
set.seed(42)
n <- 100
x <- seq(-5, 5, n)
y <- sin(x) + rnorm(n, sd = 5)
d <- data.frame(x, y)
# Graphin the fake data.
ggplot(data, aes(x = x, y = y)) +
geom_point(size = 2) +
stat_smooth(method = "lm", formula = y ~ poly(x, 25), se = FALSE, color = "red", size = 2) +
labs(title = "Overfit Model (25-Degree Polynomial IV") +
theme_minimal()
setwd("~/Dropbox/STATS/Psych 101/grading/SP25/SP2025 - CheckIns/")
setwd("~/Dropbox/STATS/Psych 101/grading/SP25/SP2025 - CheckIns/")
usernames <- read.csv("0.1_Stats_Onboard_SP25-2.csv")
names(usernames)
usernames <- usernames[,2:4]
names(usernames)[3] <- "SIS.User.ID"
head(usernames)
grades <- read.csv("../2025-05-22T1617_Grades-PSYCH_101-SP25.csv")
grades$Exam <- as.numeric(grades$Mega.Exam.Current.Score)
grades$Quiz <- as.numeric(grades$Quizzes.Unposted.Final.Score)
grades$Quiz <- as.numeric(grades$Quizzes.Current.Score)
as.numeric(grades$Quizzes.Current.Score)
roster <- grades
names(roster)
roster <- roster[,c(1:5, 80, 81)]
head(roster)
head(roster)
roster <- grades
names(roster)
roster <- roster[,c(1:5, 76:77)]
head(roster)
matched <- merge(roster, usernames, by = "SIS.User.ID", all.x = T, all.y = F)
write.csv(matched, "../rosteruser.csv", row.names = F) # fill in missing emails, then comment out so you don't accidentally erase them and have to redo (SP23...)
#write.csv(matched, "../rosteruser.csv", row.names = F) # fill in missing emails, then comment out so you don't accidentally erase them and have to redo (SP23...)
matched <- read.csv("../rosteruser.csv") # SEE ABOVE!! ^^
## THE CHECK-INS :)
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
path = list.files(pattern="*.csv")
path # paste transposed into excel file so can tell students which they missed.
# Load Data
ci.data <- list()
for (i in 1:length(path)){
hold <- read.csv(path[[i]])
hold <- hold[hold$Timestamp > "2025/01/01",] # note : errors mean missing data from this semester; identify i to find empty checkin
hold <- data.frame(hold[,2], 1)
names(hold) <- c("Username", paste("CI", i, sep = ""))
ci.data[[i]] <- hold[,1:2]
}
i
for(i in 1:length(ci.data)){ # for when you don't forget to have all students have email
print(head(ci.data[[i]]))}
## MERGING
core <- matched
missing <- list()
for(i in c(1:length(ci.data))){
core <- merge(core, ci.data[[i]], by = "Username", all.x = TRUE, all.y = FALSE)
missing[[i]] <- subset(ci.data[[i]], !(Username %in% core$Username))
core <- unique(core)
}
## ORGANIZE DATA FROM MISSING FOLKS
missing
Merged=Reduce(function(x, y) merge(x, y,all.x=T, all.y = T,by="Username"),missing)
Merged$TOTAL <- rowSums(Merged[,2:length(Merged)], na.rm = T)
missingfolks <- unique(with(Merged, data.frame(Username, TOTAL))) # data frame of missing folks.
missingfolks # can use this list to ID missing usernames; fill in rosterusername dataset; then rerun script.
names(core)
core$CITOTAL <- rowSums(core[,10:ncol(core)], na.rm = T)
hist(core$CITOTAL)
write.csv(core, "../checkinsucb_SP25.csv", row.names = FALSE)
write.csv(missingfolks, "../missingfolks_SP25.csv", row.names = FALSE)
core$Exam
core$CITOTAL
summary(lm(EXAM ~ CIT, data = core))
summary(lm(Exam ~ CIT, data = core))
summary(lm(Exam ~ CITOTAL, data = core))
summary(lm(Quiz ~ CITOTAL, data = core))
summary(lm(Exam ~ CITOTAL, data = core))
grades
names(grades)
exams <- grades[,c(1:9)]
names(exams)
summary(lm(Exam ~ CITOTAL, data = core))
summary(lm(scale(Exam) ~ scale(CITOTAL), data = core))
mod <- lm(scale(Exam) ~ scale(CITOTAL), data = core)
summary(mod)
confint(mod)
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="l"))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="l", col = 'red'))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="d", col = 'red'))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="p", col = 'red'))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type=19, col = 'red'))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, pch=19, col = 'red'))
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="l", col = 'red', lwd = 9))
d <- read.csv("~/Downloads/0.1_Stats_Onboard_DVC_FA25.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:7, 23:26, 43)]
names(d)
d <- read.csv("~/Downloads/0.1_Stats_Onboard_DVC_FA25.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:4, 7:9, 30:36)]
names(d)
renaming <- c("time","class","major","has.laptop","has.phone","take.stats","write.code", "know.prog",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep",
"learn.concept", "learn.r", "can.science", "should.science", "truth.people",
"not.psychsci", "perf.pred", "noperf.pred","too.complex","epistemology")
names(d) <- renaming
names(d)
d <- read.csv("~/Downloads/0.1_Stats_Onboard_DVC_FA25.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:4, 7:9, 30:35)]
names(d)
renaming <- c("time","class","major","has.laptop","has.phone","take.stats","write.code", "know.prog",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep",
"learn.concept", "learn.r", "can.science", "should.science", "truth.people",
"not.psychsci", "perf.pred", "noperf.pred","too.complex","epistemology")
names(d) <- renaming
head(d)
names(d)
d[] <- lapply(d, gsub, pattern = "1 (Strongly Disagree)", replacement = "1", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "5 (Strongly Agree)", replacement = "5", fixed = TRUE)
head(d) # checking my work
tail(d) # checking my work
write.csv(d, "~/Downloads/dvc_onboard_SP25.csv", row.names = F)
write.csv(d, "~/Downloads/dvc_onboard_FA25.csv", row.names = F)
d <- read.csv("~/Dropbox/!WHY STATS/Chapter Datasets/hormone_data.csv", stringsAsFactors = T)
## Q1. How many individuals are in this dataset?
nrow(d)
## Q2. How many variables are in this dataset?
ncol(d)
## Q9. What is the standard deviation of the variable test?
sd(d$test)
## Q9. What is the standard deviation of the variable test?
sd(d$test, na.rm = T)
d$test - mean(d$test)
d$test - mean(d$test, na.rm = T)
sum(d$test - mean(d$test, na.rm = T), na.rm = T)
d$test - mean(d$test, na.rm = T)
resid <- d$test - mean(d$test, na.rm = T)
sum(resid^2)
sum(resid^2, na.rm = T)
SST <- sum(resid^2, na.rm = T)
SST/nrow(d)
sqrt(SST/nrow(d))
sqrt(SST)/nrow(d)
## Q9. What is the standard deviation of the variable test?
sd(d$test, na.rm = T)
sqrt(SST/nrow(d))
d <- read.csv("~/Downloads/0.1_Stats_Onboard_DVC_FA25.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:4, 7:9, 30:35)]
names(d)
renaming <- c("time","class","major","has.laptop","has.phone","take.stats","write.code", "know.prog",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep",
"learn.concept", "learn.r", "can.science", "should.science", "truth.people",
"not.psychsci", "perf.pred", "noperf.pred","too.complex","epistemology")
data.dictionary <- data.frame(variable = renaming, item = names(d))
write.csv(data.dictionary, "~/Downloads/CODEBOOK_grad_onboard_SP25.csv", row.names = F)
datasets::sleep
d <- datasets::sleep
d
datasets()
?datasets
library(help = "datasets")
UCBAdmissions
print(UCBAdmissions)
Titanic
trees
trees
?trees
View(trees)
##### FUNCTIONS TO NAVIGATE DATASETS
head(trees)
tail(trees)
nrow(trees)
ncol(trees)
names(trees)
trees
trees[1,]
trees[1,2]
trees[1:6,2]
trees[1:6,2:3]
trees[1:6,c(1,2)]
## working with a variable in a dataset.
Height
trees$Height
hist(trees$Height)
d <- read.csv("~/Dropbox/!WHY STATS/Chapter Datasets/selfesteemdata.csv", stringsAsFactors=TRUE)
View(d)
selfy <- read.csv("~/Dropbox/!WHY STATS/Chapter Datasets/selfesteemdata.csv", stringsAsFactors=TRUE)
selfy$age
hist(selfy$age)
d <- read.csv("~/Downloads/0.1_HonorStats_Onboard_FA25.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:6, 23:26, 43)]
names(d)
renaming <- c("time", "has.laptop", "write.code", "know.prog", "has.data", "know.r",
"can.import", "can.clean", "can.graph", "can.render", "can.lm",
"can.interp", "can.pvalue", "can.sevsd", "can.95ci", "can.forloop",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep", "learn.concept", "learn.r",
"can.science", "should.science", "truth.people", "not.psychsci", "perf.pred", "noperf.pred","too.complex",
"epistemology", "consent")
data.dictionary <- data.frame(variable = renaming, item = names(d))
renaming <- c("time", "area", "has.laptop", "write.code", "know.prog", "has.data", "know.r",
"can.import", "can.clean", "can.graph", "can.render", "can.lm",
"can.interp", "can.pvalue", "can.sevsd", "can.95ci", "can.forloop",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep", "learn.concept", "learn.r",
"can.science", "should.science", "truth.people", "not.psychsci", "perf.pred", "noperf.pred","too.complex",
"epistemology", "consent")
data.dictionary <- data.frame(variable = renaming, item = names(d))
write.csv(data.dictionary, "~/Downloads/CODEBOOK_honor_onboard_FA25.csv", row.names = F)
names(d) <- renaming
head(d)
names(d)
d[] <- lapply(d, gsub, pattern = "Maybe I Could Do This?", replacement = "Maybe", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "Definitely Could Do This", replacement = "Yes", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "Not at All", replacement = "No", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "1 (Strongly Disagree)", replacement = "1", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "5 (Strongly Agree)", replacement = "5", fixed = TRUE)
head(d) # checking my work
tail(d) # checking my work
d$consent
d$consent == 'yes, you can add my responses to a class dataset.'
d[-d$consent == 'yes,]
d[-(d$consent == 'yes),]
d[d$consent == 'yes, you can add my responses to a class dataset.'),] # removing one individual and all rows
d[d$consent == 'yes, you can add my responses to a class dataset.',]
d <- d[d$consent == 'yes, you can add my responses to a class dataset.',] # we grant consent.
d$consent[33]
write.csv(d, "~/Dropbox/!GRADSTATS/honor_FA25_datasets/Onboarding Data/honor_onboard_FA25.csv", row.names = F)
door10000 <- array() # this defines an empty array; a place to "store" my values
for(i in c(1:100000)){ # this starts the for-loop, and tells R I want to repeat some process 100 times, and keep track with the variable i
door10000[i] <- paste("door", i, sep = "") # the paste() function sticks the string "door" and the variable i together, separated by no value
# since i updates every time we iterate through the loop, each door will increase from 1 to 100.
# the assign <- sticks this value to the variable door100 in position i
} # this ends the loop
door10000 # testing to see if the loop works. it did.
door10000 <- array() # this defines an empty array; a place to "store" my values
for(i in c(1:100000)){ # this starts the for-loop, and tells R I want to repeat some process 100 times, and keep track with the variable i
door10000[i] <- paste("door", i, sep = "") # the paste() function sticks the string "door" and the variable i together, separated by no value
# since i updates every time we iterate through the loop, each door will increase from 1 to 100.
# the assign <- sticks this value to the variable door100 in position i
} # this ends the loop
door10000 # testing to see if the loop works. it did.
some(door10000)
door10000(sample(1:1000))
door10000[sample(1:1000, 10)]
rownames(door10000[sample(1:1000, 10)])
door10000[sample(1:1000, 10)]
door10000[sample(1:1000, 10)]
door10000[sample(1:10000, 10),]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
door10000[sample(1:10000, 10)]
tail(door10000)
win.stay10000 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
win.switch10000 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
for(i in c(1:10000)){ # running 10000 simulations.
choice <- sample(door10000, 1) # the new set of 10000 doors
treasure <- sample(door10000, 1)
can.open <- setdiff(door10000, c(choice, treasure))
monty.open <- sample(can.open, 98) # monty will open 98 other doors, leaving my choice + the treasure.
choice.switch <- sample(setdiff(door10000, c(monty.open, choice)), 1) # if switch, I can still only choose from whatever is left.
win.stay100[i] <- ifelse(choice == treasure, "WIN", "LOSE") # this is the result if we stay with our initial choice
win.switch100[i] <- ifelse(choice.switch == treasure, "WIN", "LOSE") # this is the result if we switch
}
win.stay10000 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
win.switch10000 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
for(i in c(1:10000)){ # running 10000 simulations.
choice <- sample(door10000, 1) # the new set of 10000 doors
treasure <- sample(door10000, 1)
can.open <- setdiff(door10000, c(choice, treasure))
monty.open <- sample(can.open, 98) # monty will open 98 other doors, leaving my choice + the treasure.
choice.switch <- sample(setdiff(door10000, c(monty.open, choice)), 1) # if switch, I can still only choose from whatever is left.
win.stay10000[i] <- ifelse(choice == treasure, "WIN", "LOSE") # this is the result if we stay with our initial choice
win.switch10000[i] <- ifelse(choice.switch == treasure, "WIN", "LOSE") # this is the result if we switch
}
sum(win.stay10000 == "WIN")/length(win.stay10000) # probability if I stay. Note that rather than divide by 1000, I'm dividing by the value of length(). If I change the # of simulations to run above, I don't have to update my code here. This is GOOD PRACTICE.
sum(win.switch10000 == "WIN")/length(win.switch10000) # YEAH!!!!
can.open
length(can.open)
win.stay100 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
win.switch100 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
for(i in c(1:10000)){ # running 10000 simulations.
choice <- sample(door100, 1) # the new set of 10000 doors
treasure <- sample(door100, 1)
can.open <- setdiff(door100, c(choice, treasure))
monty.open <- sample(can.open, 98) # monty will open 98 other doors, leaving my choice + the treasure.
choice.switch <- sample(setdiff(door100, c(monty.open, choice)), 1) # if switch, I can still only choose from whatever is left.
win.stay100[i] <- ifelse(choice == treasure, "WIN", "LOSE") # this is the result if we stay with our initial choice
win.switch100[i] <- ifelse(choice.switch == treasure, "WIN", "LOSE") # this is the result if we switch
}
door100 <- array() # this defines an empty array; a place to "store" my values
for(i in c(1:100)){ # this starts the for-loop, and tells R I want to repeat some process 100 times, and keep track with the variable i
door100[i] <- paste("door", i, sep = "") # the paste() function sticks the string "door" and the variable i together, separated by no value
# since i updates every time we iterate through the loop, each door will increase from 1 to 100.
# the assign <- sticks this value to the variable door100 in position i
} # this ends the loop
door100 # testing to see if the loop works.
tail(door100)
win.stay100 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
win.switch100 <- array() # defining a new place to save values when we have 100 doors. I could call this anything.
for(i in c(1:10000)){ # running 10000 simulations.
choice <- sample(door100, 1) # the new set of 10000 doors
treasure <- sample(door100, 1)
can.open <- setdiff(door100, c(choice, treasure))
monty.open <- sample(can.open, 98) # monty will open 98 other doors, leaving my choice + the treasure.
choice.switch <- sample(setdiff(door100, c(monty.open, choice)), 1) # if switch, I can still only choose from whatever is left.
win.stay100[i] <- ifelse(choice == treasure, "WIN", "LOSE") # this is the result if we stay with our initial choice
win.switch100[i] <- ifelse(choice.switch == treasure, "WIN", "LOSE") # this is the result if we switch
}
sum(win.stay100 == "WIN")/length(win.stay100) # probability if I stay. Note that rather than divide by 100, I'm dividing by the value of length(). If I change the # of simulations to run above, I don't have to update my code here. This is GOOD PRACTICE.
sum(win.switch100 == "WIN")/length(win.switch100) # YEAH!!!!
bucket <- array() # one place to save output (1-dimensional)
for(i in c(1:100)){
bucket[i] <- i*i
}
bucket
plot(bucket)
7*8
d <- read.csv("~/Downloads/0.1_HonorStats_Onboard_FA25-2.csv", stringsAsFactors = T)
names(d)
d <- d[,-c(2:6, 23:26, 43)]
names(d)
renaming <- c("time", "area", "has.laptop", "write.code", "know.prog", "has.data", "know.r",
"can.import", "can.clean", "can.graph", "can.render", "can.lm",
"can.interp", "can.pvalue", "can.sevsd", "can.95ci", "can.forloop",
"self.skills", "class.skills", "self.excite", "class.excite", "self.prep", "class.prep", "learn.concept", "learn.r",
"can.science", "should.science", "truth.people", "not.psychsci", "perf.pred", "noperf.pred","too.complex",
"epistemology", "consent")
data.dictionary <- data.frame(variable = renaming, item = names(d))
write.csv(data.dictionary, "~/Downloads/CODEBOOK_honor_onboard_FA25.csv", row.names = F)
names(d) <- renaming
head(d)
names(d)
d[,c(7:16)]
## Shortening string data
d[] <- lapply(d, gsub, pattern = "Maybe I Could Do This?", replacement = "Maybe", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "Definitely Could Do This", replacement = "Yes", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "Not at All", replacement = "No", fixed = TRUE)
## Reworking likert scale data.
d[] <- lapply(d, gsub, pattern = "1 (Strongly Disagree)", replacement = "1", fixed = TRUE)
d[] <- lapply(d, gsub, pattern = "5 (Strongly Agree)", replacement = "5", fixed = TRUE)
head(d) # checking my work
tail(d) # checking my work
d$consent == 'yes, you can add my responses to a class dataset.'
d <- d[d$consent == 'yes, you can add my responses to a class dataset.',] # we grant consent.
write.csv(d, "~/Dropbox/!GRADSTATS/honor_FA25_datasets/Onboarding Data/honor_onboard_FA25.csv", row.names = F)
d <- read.csv("~/Dropbox/!GRADSTATS/honor_FA25_datasets/Onboarding Data/honor_onboard_FA25.csv", stringsAsFactors = T, na.strings = "")
par(mfrow = c(1,2))
hist(d$self.skills, breaks = c(0:5),
col = 'black', bor = 'white', main = "Computer Skills\n(Self-Perceptions)")
abline(v = mean(d$self.skills), lwd = 4, col = 'red')
abline(v = mean(d$self.skills) + sd(d$self.skills),
lwd = 2, lty = "dashed", col = 'red')
abline(v = mean(d$self.skills) - sd(d$self.skills),
lwd = 2, lty = "dashed", col = 'red')
hist(d$class.skills, breaks = c(0:5),
col = 'black', bor = 'white', main = "Computer Skills\n(Perceptions of Classmates)")
abline(v = mean(d$class.skills), lwd = 4, col = 'red')
abline(v = mean(d$class.skills) + sd(d$class.skills),
lwd = 2, lty = "dashed", col = 'red')
abline(v = mean(d$class.skills) - sd(d$class.skills),
lwd = 2, lty = "dashed", col = 'red')
selfes <- read.csv("~/Dropbox/!GRADSTATS/Datasets/Self-Esteem Dataset/data.csv",
stringsAsFactors = T,
na.strings = "0", sep = "\t")
