SST <- sum((mod1$model$PSYSCI - mean(mod1$model$PSYSCI))^2)
(SSTx - SSE)/SSE
SSTx <- sum((mod1$model$PSYSCI - mean(mod1$model$PSYSCI))^2)
(SSTx - SSE)/SSE
summary(mod1)$r.squared
mod1$model$PSYSCI
mean(mod1$model$PSYSCI)
names(d)
plot(PSYSCI ~ self.excite, data = d)
mod1 <- lm(PSYSCI ~ self.excite, data = d)
abline(mod1)
plot(mod1)
summary(mod1M)$r.squared
p <- read.csv("./gradstats/datasets/Personality and Random Numbers/data.csv")
head(p)
names(p)
RN.df <- p[,2:21]
names(RN.df)
psych::alpha(RN.df)
RN.df <- scale(RN.df)
psych::alpha(RN.df)
names(p)
E.df <- p[,22:31]
names(E.df)
psych::alpha(E.df)
range(E.df)
p <- read.csv("./gradstats/datasets/Personality and Random Numbers/data.csv",
na.strings = "0")
head(p)
names(p)
RN.df <- p[,2:21]
RN.df <- scale(RN.df)
names(RN.df)
RN.df
psych::alpha(RN.df)
E.df <- p[,22:31]
names(E.df)
range(E.df)
range(E.df, na.rm = T)
E.df <- E.df[,6-c(2,4,6,8,10)]
Eneg.df <- E.df[,c(2,4,6,8,10)]
Epos.df <- E.df[,c(1,3,5,7,9)]
Eneg.df <- 6-Eneg.df
Ex.df <- data.frame(Epos.df, Eneg.df)
psych::alpha(Ex.df)
p$EXTRA <- rowMeans(Ex.df, na.rm = T)
p$RANDO <- rowMeans(RN.df, na.rm = T)
plot(RANDO ~ EXTRA, p)
summary(lm(RANDO ~ EXTRA, p))
summary(lm(RANDO ~ C1, p))
summary(lm(RANDO ~ O1, p))
summary(lm(RANDO ~ N1, p))
summary(lm(RANDO ~ N2, p))
summary(lm(RANDO ~ A1, p))
summary(lm(RANDO ~ C2, p))
summary(lm(RANDO ~ C3, p))
summary(lm(RANDO ~ 03, p))
summary(lm(RANDO ~ O3, p))
plot(RANDO ~ EXTRA, p)
hist(p$RANDO)
se <- bucket()
se <- array()
se <- array()
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
nmod <- lm(PSYSCI ~ self.excite, data = nd)
se[i] <- coef(nmod)[2]
}
hist(se)
mean(se)
coef(mod)[2]
coef(mod1)[2]
se <- array()
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
nmod <- lm(PSYSCI ~ self.excite, data = nd)
se[i] <- coef(nmod)[2]
}
hist(se)
mean(se)
coef(mod1)[2]
se <- array()
for(i in c(1:10000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
nmod <- lm(PSYSCI ~ self.excite, data = nd)
se[i] <- coef(nmod)[2]
}
hist(se)
mean(se)
coef(mod1)[2]
coef(mod1M)[2]
se <- array()
for(i in c(1:10000)){
nd <- dminus[sample(1:nrow(dminus), nrow(dminus), replace = T),]
nmod <- lm(PSYSCI ~ self.excite, data = nd)
se[i] <- coef(nmod)[2]
}
hist(se)
mean(se)
coef(mod1M)[2]
sd(se)
coef(mod1)[2] + 1.96*sd(se)
coef(mod1)[2] - 1.96*sd(se)
confint(mod1)
names(d)
mod2 <- lm(PSYSCI ~ can.lm, d)
plot(PSYSCI ~ can.lm, d)
coef(mod2)
summary(mod2)
summary(d)
mod2 <- lm(PSYSCI ~ has.data, d)
plot(PSYSCI ~ has.data, d)
summary(mod2)
summary(d)
library(gplots)
install.packages('gplots')
library(gplots)
plotmeans(PSYSCI ~ has.data, d)
d$Q1E
w <- read.csv("~/Downloads/Class7-WHR20_DataForFigure2.1.csv")
head(w)
GOOD.df <- with(w,
data.frame(Social.support,
Healthy.life.expectancy,
Freedom.to.make.life.choices,
Generosity,
Perceptions.of.corruption))
psych::alpha(GOOD.df)
GOOD.df <- with(w,
data.frame(Social.support,
Healthy.life.expectancy,
Generosity))
psych::alpha(GOOD.df)
GOOD.df <- with(w,
data.frame(scale(Social.support),
scale(Healthy.life.expectancy),
scale(Freedom.to.make.life.choices),
scale(Generosity),
scale(Perceptions.of.corruption)))
psych::alpha(GOOD.df)
GOOD.df <- with(w,
data.frame(scale(Social.support),
scale(Healthy.life.expectancy),
scale(Freedom.to.make.life.choices),
scale(Generosity))
)
psych::alpha(GOOD.df)
GOOD.df <- with(w,
data.frame(scale(Social.support),
scale(Healthy.life.expectancy),
scale(Freedom.to.make.life.choices)))
GOOD.df <- with(w,
data.frame(scale(Social.support),
scale(Healthy.life.expectancy),
scale(Freedom.to.make.life.choices)))
psych::alpha(GOOD.df)
w$GOOD <- rowMeans(GOOD.df)
names(w)
plot(GOOD ~ Ladder.score, data = w)
x1 <- lm(GOOD ~ Ladder.score, data = w)
abline(x1)
summary(x1)
names(w)
plot(GOOD ~ Perceptions.of.corruption, w)
plot(GOOD ~ Logged.GDP.per.capita, w)
names(d) # identifying the scale items
hist(d$can.forloop)
plot(d$can.forloop)
table(d$can.forloop)
data.frame(d$can.forloop)
cbind(table(d$can.forloop))
rbind(table(d$can.forloop))
bucket <- data.frame()
bucket[1] <- rbind(table(d$can.forloop))
bucket <- data.frame(NULL)
bucket[1] <- rbind(table(d$can.forloop))
bucket <- data.frame(NULL, NULL, NULL)
bucket[1] <- rbind(table(d$can.forloop))
bucket
bucket <- array()
bucket[1] <- rbind(table(d$can.forloop))
rbind(table(d$can.forloop))
bucket <- data.frame(cbind(Maybe = NULL, No = NULL, Yes = NULL))
bucket
bucket[1] <- rbind(table(d$can.forloop))
bucket <- cbind(Maybe = NULL, No = NULL, Yes = NULL)
bucket
bucket[1] <- rbind(table(d$can.forloop))
bucket <- cbind("Maybe" = NULL, "No" = NULL, "Yes" = NULL)
bucket[1]
bucket
bucket[1] <- rbind(table(d$can.forloop))
bucket <- data.frame("Maybe" = NULL, "No" = NULL, "Yes" = NULL)
bucket
bucket <- matrix("Maybe" = NULL, "No" = NULL, "Yes" = NULL)
bucket <- data.frame()
bucket[1,] <- rbind(table(d$can.forloop))
bucket[1] <- rbind(table(d$can.forloop))
bucket
bucket[2] <- rbind(table(d$can.forloop))
bucket <- data.frame()
rbind(table(d$can.forloop))
bucket[1,] <- rbind(table(d$can.forloop))
bucket
bucket <- data.frame()
bucket[1,] <- rbind(table(d$can.forloop))
bucket <- data.frame()
bucket[1] <- rbind(table(d$can.forloop))
bucket[1,] <- rbind(table(d$can.forloop))
bucket
bucket <- matrix(ncol = 3)
bucket
bucket[1]
bucket[1,]
bucket[1,] <- rbind(table(d$can.forloop))
bucket
bucket <- matrix(ncol = 3, dimnames = c("Maybe", "Yes", "No"))
bucket <- matrix(ncol = 3, dimnames = list("Maybe", "Yes", "No"))
bucket <- matrix(ncol = 3)
summary(nd$can.forloop)
bucket <- matrix(ncol = 3)
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
bucket[i] <- summary(nd$can.forloop)
}
bucket <- matrix(ncol = 3)
summary(nd$can.forloop)
rbind(summary(nd$can.forloop))
bucket <- matrix(ncol = 3)
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
bucket[i] <- rbind(summary(nd$can.forloop))
}
rbind(table(nd$can.forloop))
bucket <- matrix(ncol = 3)
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
bucket[i] <- rbind(table(nd$can.forloop))
}
bucke
bucket
bucket <- matrix(ncol = 3)
bucket
bucket <- matrix(ncol = 3)
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
bucket[i,] <- rbind(table(nd$can.forloop))
}
rbind(table(nd$can.forloop))
bucket[i,] <- rbind(summary(nd$can.forloop))
bucket[1,] <- rbind(summary(nd$can.forloop))
bucket
bucket[2,] <- rbind(summary(nd$can.forloop))
bucket[2,]
bucket[2]
bucket <- matrix(ncol = 3, nrow = 1000)
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
bucket[i,] <- rbind(summary(nd$can.forloop))
}
names(bucket)
bucket
colnames(bucket)
colnames(bucket) <- c("M", "Y", "N")
bucket
summary(bucket)
summary(as.factor(bucket))
summary(nd$can.forloop)
bucket <- array()
summary(d$can.forloop)
summary(d$can.forloop)[2]
summary(d$can.forloop)[2] - summary(d$can.forloop)[1]
summary(d$can.forloop)[1]
summary(d$can.forloop)[2]
summary(d$can.forloop)[2] - (summary(d$can.forloop)[1] + summary(d$can.forloop)[3])
plot(d$can.forloop)
summary(d$can.forloop)[2] - (summary(d$can.forloop)[1] + summary(d$can.forloop)[3])
summary(d$can.forloop)[2] - (summary(d$can.forloop)[1] + summary(d$can.forloop)[3])
summary(d$can.forloop)[2] - (summary(d$can.forloop)[1] + summary(d$can.forloop)[3])
s <- summary(d$can.forloop)
s
s[2]  - (s[1] + s[3])
bucket <- array()
summary(d$can.forloop)[2] - summary(d$can.forloop)[3]
for(i in c(1:1000)){
nd <- d[sample(1:nrow(d), nrow(d), replace = T),]
s <- summary(nd$can.forloop)
bucket[i] <- s[2]  - (s[1] + s[3])
}
hist(bucket)
mean(bucket)
bucket > 0
sum(bucket > 0)
plot(can.science ~ self.excite, data = d)
mod1 <- lm(d$can.science ~ self.excite, data = d)
abline(mod1)
plot(can.science ~ self.excite, data = d)
mod1 <- lm(d$can.science ~ self.excite, data = d)
abline(mod1)
plot(should.science ~ self.excite, data = d)
mod1 <- lm(should.science ~ self.excite, data = d)
abline(mod1)
plot(mod1)
plot(should.science ~ self.excite, data = d)
mod1 <- lm(should.science ~ self.excite, data = d)
abline(mod1)
plot(jitter(should.science) ~ self.excite, data = d)
plot(mod1)
plot(jitter(should.science) ~ self.excite, data = d)
mod1 <- lm(should.science ~ self.excite, data = d)
abline(mod1)
plot(mod1)
plot(jitter(should.science) ~ self.excite, data = d)
mod1 <- lm(should.science ~ self.excite, data = d)
abline(mod1)
plot(mod1)
plot(jitter(should.science) ~ self.excite, data = d)
mod1 <- lm(should.science ~ self.excite, data = d)
abline(mod1)
names(d)[,c(25:31)]
names(d)[c(25:31)] # identifying the scale items
hist(d$PSYSCI) # the graph of this new variable.
hist(d$PSYSCI, xlim = c(1,5)) # the graph of this new variable.
lm(PSYSCI ~ 1, data = d) # predicting PSYSCI from a constant (1), using the datset = d
mod0 <- lm(PSYSCI ~ 1, data = d) # saving this as a model object
coef(mod0) # looking at the coefficients
mod0$residuals # finding the residuals
bros <- read.csv("~/Desktop/brothers.txt")
head(bros)
bros <- read_table("~/Desktop/brothers.txt")
bros <- read_table("~/Desktop/brothers.txt", col_names = F)
head(bros)
g <- read.csv("~/Downloads/4.1_GradMini.csv", stringsAsFactors = T)
names(g)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
head(g)
names(g)
g <- g[,c(1,3:20, 24)]
head(g)
names(g)
gnames <- names(g)
names(g)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
names(g)
g <- g[,c(1,3:21, 24)]
gnames <- names(g)
names(g)
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
names(g)
g <- g[,c(1,3:24)]
g <- read.csv("~/Downloads/4.1_GradMiniDat.csv", stringsAsFactors = T)
names(g)
g <- g[,c(1,3:24)]
names(g)
gnames <- names(g)
names(g) <- c("Time", "howgo", "howlab3", "howR", "hunger", "stress", "social", "organized", "open", "agreeable",
"givedata", "love2scroll", "tired", "cooladvisor", "lovebay", "had.breakfast", "have.water", "food.pref", "check.phone", "hrs.sleep",
"diff", "did.for", "checkin.go")
table(gnames, g)
cbind(gnames, g)
cbind(gnames, names(g))
data.frame(gnames, names(g))
data.frame(Variable = names(g), Item = gnames)
minig_code <- data.frame(Variable = names(g), Item = gnames)
head(minig_code)
write.csv(minig_code, "~/Dropbox/!GRADSTATS/gradlab/Datasets/MiniGrad/mini_grad_codebook.csv", row.names = F)
write.csv(minig_code, "~/Dropbox/!GRADSTATS/gradlab/Datasets/MiniGrad/mini_grad_codebook.csv", row.names = F)
minig_code
dat<- data.frame(t=seq(0, 2*pi, by=0.1) )
xhrt <- function(t) 16*sin(t)^3
yhrt <- function(t) 13*cos(t)-5*cos(2*t)-2*cos(3*t)-cos(4*t)
dat$y=yhrt(dat$t)
dat$x=xhrt(dat$t)
with(dat, plot(x,y, type="l"))
greyScale <- colorRampPalette(c("black","white"))
# function to draw shape
plotHeart <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop
mapply(plotHeart,seq(16,0,length.out=100),greyScale(100))
greyScale <- colorRampPalette(c("pink","white"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
greyScale <- colorRampPalette(c("pink","red"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
d <- read.csv("../datasets/Self-Esteem Dataset/data.csv",
stringsAsFactors = T,
na.strings = "0", sep = "\t")
names(d)[c(25:31)]
names(d)
d <- read.csv("../datasets/Grad Onboard 2025/grad_onboard_SP25.csv",
stringsAsFactors = T)
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
greyScale <- colorRampPalette(c("pink","red"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
greyScale <- colorRampPalette(c("pink","red"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
?mappy
?mapply
seq(0,2*pi,length.out=100)
r*sin(t)^3
seq(16,0)
seq(16,0,length.out = 100)
polygon(x,y,col=col,border=NA)
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
greyScale <- colorRampPalette(c("pink","red"))
greyScale <- colorRampPalette(c("pink","red"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop
mapply(secretmessage,seq(16,0,length.out=100),greyScale(100))
#| eval: false
#| include: true
greyScale <- colorRampPalette(c("pink","red"))
# function to draw shape
secretmessage <- function(r, col){
t <- seq(0,2*pi,length.out=100)
x <- r*sin(t)^3
y <- (13*r/16)*cos(t) - (5*r/16)*cos(2*t) - (2*r/16)*cos(3*t) - (r/16)*cos(4*t)
polygon(x,y,col=col,border=NA)
}
# create new plot canvas
plot.new()
# limits are approximate here
plot.window(xlim=c(-16,16),ylim=c(-16,13))
# use mapply to loop; invisible to turn off an annoying output.
invisible(mapply(secretmessage,seq(16,0,length.out=100),greyScale(100)))
## source : https://stackoverflow.com/questions/6542825/equation-driven-smoothly-shaded-concentric-shapes
## https://stackoverflow.com/questions/12984991/stop-lapply-from-printing-to-console
names(d)
summary(lm(self.skills ~ class.skills, data = d))
summary(lm(self.skills ~ class.skills, data = d))
plot(self.skills ~ class.skills, data = d)
abline(lm(self.skills ~ class.skills, data = d))
names(d)
plot(self.skills ~ know.r, data = d)
summary(lm(self.skills ~ know.r, data = d))
summary(lm(self.skills ~ d$write.code, data = d))
lm(self.skills ~ 1, data = d) # predicting PSYSCI from a constant (1), using the datset = d
mod0 <- lm(self.skills ~ 1, data = d) # saving this as a model object
coef(mod0) # looking at the coefficients
mod0$residuals # finding the residuals
mod1 <- lm(self.skills ~ class.skills, data = d)
mod1 <- lm(self.skills ~ class.skills, data = d)
mod1$residuals
